# Design Document

**Name**:Moon.

## <span id="jump1">.gitlet所包含的文件以及目录</span>

### objects(Dir)
这一个目录包含了众多以`03`,`7a`等编号首两个组成的目录，这是因为我们所用的Hash编码为`SHA-1`编码，将文件所有内容编码后获得了40为SHA-1编码，为减少文件查找的复杂度我们将其首两个字符提出并作为目录的名字，后38位作为文件本身的名字。

在原本的git中，应该具有tree，blob和commit三种对象同等的存在Objects目录下，但是在gitlet中简化到只在CWD下存储单纯的文件，所以无需tree对象，而为了高效率完成`global-log`方法，我选择在gitlet中将所有的`commit`对象都设置在同一个文件夹下面。

#### Commit(Dir)
用于存储commit对象，且直接将文件名设置为SHA-1哈希码。

### refs(Dir) 
refs文件夹用于存储Gitle仓库的引用，而这些引用都指向特定的提交，而这个refs目录之下的heads文件夹和remote文件夹分别对应着本地分支和远程分支的引用

#### heads
heads对应的是本地的仓库中的所有分支，如果我们有一个`master`和一个`develop`两个文件在里面，则对应着两个分支为`master`和`develop`。

需注意的是这存储的实际上也是一个Commit的SHA-1的id，只不过放在这里更具有结构性，通过HEAD定位到这里并读取文件内容得到id，则可以通过这个id找到Objects中存储的真实的Commit对象将其反序列化。

#### remotes
对应各个远程仓库，其中的每一个文件夹对应一个远程仓库，再往深的文件则对应仓库的分支

### INDEX(File) 
以一个文件模拟暂存区，可以定义一个类并将其序列化存入该文件

### HEAD(File)
存一个路径表示当前分支是对应的什么，如`refs/heads/master`

## Classes and Data Structures

### Class 1 Commit类
将每一个提交都看作一个对象，这个对象应该包含

1.parents(即对父节点的引用)

2.id(表示该提交对象的hashcode编码)

3.message(commit提交的时候带的类似于备注的信息)

4.timestamp(时间戳)

5.fileMap(一个Map，映射到对应的blob)

### Class 2 Blob类
每一个文件的不同版本都可以视为一个Blob，这个对象只包含`id`和`contents`两个成员，分别表示该类的hashcode和内容字符串

这个Blob类较为特殊，它是id和文本内容的映射，也正是它映射的是用户真正要存储的文件，所以才能以这样的形式存储下来，其本身的存储还是以sha-1编码存在`Objects`中的

### Class 3 Stage类
包含一个Map用于表示添加的文件极其对应的Blob和一个List用于表示删除的文件列表，因为一个文件可能对应多个Blob版本但是删除只有文件的对应所以无需用Map来存储

### Class 4 Utils
这个类是Proj提供的工具类，也可以自己定义静态方法在这里以供项目使用

#### readObject
接受一个文件对象和一个对象的class文件，返回一个对象。即从给出的文件中反序列化一个给出的相关对象出来，并将其作为返回值返回，因此将该方法赋值给一个对象实例即可以得到从文件中读取原来存储的实例对象的功能。

#### 

## Algorithms

### Init realization
为了实现gitlet中的初始化操作，这个方法定义在仓库类中并是静态方法。

如果`.gitlet`文件夹已经存在，则退出并显示相关信息

如果`.gitlet`文件夹不存在，则创建该文件夹并把相关的目录(参照 [.gitlet所包含的文件以及目录](#jump1)), 

创造完整个仓库文件夹之后需要创建第一次提交，即默认提交。

在成功创造了第一次提交之后需要同步把HEAD更新上去，所以我们需要在写一个update本地heads的方法并加以更新，由于HEAD中村的是一个字符串路径指向heads中的分支，所以我们使用writeContents方法并且求的其相对于`.gitlet`的相对路径将其转换为字符串写入HEAD中

### Add realization
判断该文件是否存在，不存在则需要给出错误信息

按两种情况:

1.上一次的`commit`中也有这次提交的相同文件名，则需要按照对应的`contents`的SHA-1编码是否一致进行分类，若一致直接exit即可，若不一致则需要把该映射再`put`进去(因为java中相同的key对应后put进球的value所以直接put即可)

2.上一次的`commit`中没有这次提交相同的文件名，则只需要进行单纯的映射`put`即可

### Commit realization

### Checkout realization
分情况讨论有三种情况</Br>
1. 参数字符串数组长度为3 : 这种情况是将head commit的一个指定文件到CWD下并且将其替换
2. 参数字符串数组长度为4 : 这种是指定某一id的提交的指定文件并将其替换现有的CWD下的文件
3. 参数字符串数组长度为2 : 切换到指定分支，即用指定分支head commit替换CWD，并覆盖当前的文件版本，并将该指定分支修改为当前分支，即更新HEAD。<Br>
在这个过程中如果当前CWD下暂存区非空，则除非更换的分支为当前分支，则将清空暂存区。再如果检查到有一个未被跟踪的且同名(会引发冲突)的文件则需要退出并打印错误信息，即让用户删除此文件或者将其添加并提交。但若是非同名且未被跟踪则会选择保留，这是因为git中也会不管这个CWD下不被跟踪的文件，将其保留。<Br>
现在要做的是转换当前目录到目标分支，那么就首先

### Merge realization

终于到了最后的合并算法，这一步后我们的提交集终于从一个简单的序列发展成一棵树之后再最终发展成为了一张有向无环图。



## Persistence

